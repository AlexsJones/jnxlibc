.TH "jnxnetwork.h" 3 "Fri Feb 21 2014" "jnxlibc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jnxnetwork.h \- 
.PP
The API for jnxlibc networking (includes TCP, UDP )  

.SH SYNOPSIS
.br
.PP
\fC#include <stddef\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <sys/socket\&.h>\fP
.br
\fC#include <sys/un\&.h>\fP
.br
\fC#include <netinet/in\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBjnx_socket\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBlisten_callback\fP )(char *, size_t, char *)"
.br
.ti -1c
.RI "typedef void(* \fBbroadcast_listen_callback\fP )(char *, size_t)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBjnx_socket\fP * \fBjnx_network_socket_create\fP (unsigned int addrfamily, ssize_t stype)"
.br
.RI "\fIcreates a jnx socket \fP"
.ti -1c
.RI "void \fBjnx_network_socket_close\fP (\fBjnx_socket\fP *s)"
.br
.RI "\fIclose the socket but maintain the socket object  s the socket object to close \fP"
.ti -1c
.RI "void \fBjnx_network_socket_destroy\fP (\fBjnx_socket\fP *s)"
.br
.ti -1c
.RI "size_t \fBjnx_network_send\fP (\fBjnx_socket\fP *s, char *host, ssize_t port, char *msg, ssize_t msg_len)"
.br
.ti -1c
.RI "size_t \fBjnx_network_listen\fP (\fBjnx_socket\fP *s, ssize_t port, ssize_t max_connections, \fBlisten_callback\fP c)"
.br
.ti -1c
.RI "size_t \fBjnx_network_broadcast\fP (\fBjnx_socket\fP *s, ssize_t port, char *group, char *msg, ssize_t msg_len)"
.br
.ti -1c
.RI "size_t \fBjnx_network_broadcast_listen\fP (\fBjnx_socket\fP *s, ssize_t port, char *group, \fBbroadcast_listen_callback\fP c)"
.br
.in -1c
.SH "Detailed Description"
.PP 
The API for jnxlibc networking (includes TCP, UDP ) 

#include <jnxc_headers/jnxnetwork\&.h> 
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* broadcast_listen_callback)(char *, size_t)"

.SS "typedef void(* listen_callback)(char *, size_t,char *)"

.SH "Function Documentation"
.PP 
.SS "size_t jnx_network_broadcast (\fBjnx_socket\fP *S, ssize_tport, char *group, char *msg, ssize_tmsg_len)"

.PP
\fBWarning:\fP
.RS 4
not supported by IPV6 
.RE
.PP
\fBParameters:\fP
.RS 4
\fIs\fP is the socket to use to send 
.br
\fIport\fP is the target port 
.br
\fIgroup\fP is the broadcast group (e\&.g\&. 255\&.0\&.0\&.25) 
.br
\fImsg\fP is the payload to send 
.br
\fImsg_len\fP is the size of payload 
.RE
.PP
\fBReturns:\fP
.RS 4
-1 on error 
.RE
.PP

.SS "size_t jnx_network_broadcast_listen (\fBjnx_socket\fP *s, ssize_tport, char *group, \fBbroadcast_listen_callback\fPc)"

.SS "size_t jnx_network_listen (\fBjnx_socket\fP *s, ssize_tport, ssize_tmax_connections, \fBlisten_callback\fPc)"

.PP
\fBParameters:\fP
.RS 4
\fIs\fP is the socket to use to send 
.br
\fIport\fP is the target port 
.br
\fImax_connections\fP are the number of connetions in the queue 
.br
\fIc\fP is the function pointer callback for received messages 
.RE
.PP
\fBReturns:\fP
.RS 4
-1 on error 
.RE
.PP

.SS "jnx_network_send (\fBjnx_socket\fP *s, char *host, ssize_tport, char *msg, ssize_tmsg_len)"

.PP
\fBParameters:\fP
.RS 4
\fIs\fP is the socket to use to send 
.br
\fIhost\fP is the target destination 
.br
\fIport\fP is the target port 
.br
\fImsg\fP is the payload to send 
.br
\fImsg_len\fP is the size of payload 
.RE
.PP
\fBReturns:\fP
.RS 4
size_t of bytes sent, -1 for failure 
.RE
.PP

.SS "jnx_network_socket_close (\fBjnx_socket\fP *s)"

.PP
close the socket but maintain the socket object  s the socket object to close 
.SS "\fBjnx_socket\fP * jnx_network_socket_create (unsigned intaddrfamily, ssize_tstype)"

.PP
creates a jnx socket 
.PP
\fBParameters:\fP
.RS 4
\fIaddrfamily\fP this is the address family to use (e\&.g\&. AF_UNIX) 
.br
\fIstypes\fP this is the socket type to use (e\&.g\&. SOCK_STREAM) 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBjnx_socket\fP 
.RE
.PP

.SS "void jnx_network_socket_destroy (\fBjnx_socket\fP *s)"

.PP
\fBParameters:\fP
.RS 4
\fIs\fP is the socket to destroy 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for jnxlibc from the source code\&.
