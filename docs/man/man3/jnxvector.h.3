.TH "jnxvector.h" 3 "Sun Feb 1 2015" "jnxlibc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jnxvector.h \- The API for jnxlibc's implementation of vector\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'jnxtypes\&.h'\fP
.br
\fC#include 'jnxthread\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBjnx_vector_record\fP"
.br
.RI "\fIAn internal implementation of record data\&. \fP"
.ti -1c
.RI "struct \fBjnx_vector\fP"
.br
.RI "\fIThe external structure and jnx_int32erface for jnx vector\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBjnx_vector\fP * \fBjnx_vector_create\fP (void)"
.br
.RI "\fIFunction that createialises internal vector structures\&. Call this function before you call any other function from the API\&. \fP"
.ti -1c
.RI "void \fBjnx_vector_destroy\fP (\fBjnx_vector\fP **vector)"
.br
.ti -1c
.RI "void \fBjnx_vector_insert\fP (\fBjnx_vector\fP *vector, void *value)"
.br
.RI "\fIinserts jnx_int32o the next position in the vector \fP"
.ti -1c
.RI "void \fBjnx_vector_insert_ts\fP (\fBjnx_vector\fP *vector, void *value)"
.br
.ti -1c
.RI "void \fBjnx_vector_insert_at\fP (\fBjnx_vector\fP *vector, \fBjnx_int32\fP position, void *value)"
.br
.RI "\fIinserts jnx_int32o the vector at a particular position, if it doesn't exist it will be crearted \fP"
.ti -1c
.RI "void \fBjnx_vector_insert_at_ts\fP (\fBjnx_vector\fP *vector, \fBjnx_int32\fP position, void *value)"
.br
.ti -1c
.RI "void * \fBjnx_vector_last\fP (\fBjnx_vector\fP *vector)"
.br
.RI "\fIreturns the last data entry in the vector and shortens it by 1 \fP"
.ti -1c
.RI "void * \fBjnx_vector_last_ts\fP (\fBjnx_vector\fP *vector)"
.br
.ti -1c
.RI "\fBjnx_size\fP \fBjnx_vector_count\fP (\fBjnx_vector\fP *vector)"
.br
.ti -1c
.RI "\fBjnx_size\fP \fBjnx_vector_count_ts\fP (\fBjnx_vector\fP *vector)"
.br
.ti -1c
.RI "void * \fBjnx_vector_remove_at\fP (\fBjnx_vector\fP *vector, \fBjnx_int32\fP position)"
.br
.RI "\fIremoves an entry at position in the vector \fP"
.ti -1c
.RI "void * \fBjnx_vector_remove_at_ts\fP (\fBjnx_vector\fP *vector, \fBjnx_int32\fP position)"
.br
.ti -1c
.RI "\fBjnx_int32\fP \fBjnx_vector_contains\fP (\fBjnx_vector\fP *vector, void *datain, int32_t(*vector_comparison)(void *a, void *b))"
.br
.RI "\fIchecks whether a list contains a specific value \fP"
.ti -1c
.RI "\fBjnx_int32\fP \fBjnx_vector_contains_ts\fP (\fBjnx_vector\fP *vector, void *datain, int32_t(*vector_comparison)(void *a, void *b))"
.br
.in -1c
.SH "Detailed Description"
.PP 
The API for jnxlibc's implementation of vector\&. 

#include <jnxc_headers/jnxvector\&.h> 
.SH "Function Documentation"
.PP 
.SS "jnx_vector_contains (\fBjnx_vector\fP * vector, void * datain, int32_t(*)(void *a, void *b) vector_comparison)"

.PP
checks whether a list contains a specific value 
.PP
\fBParameters:\fP
.RS 4
\fIvector\fP is a pojnx_int32er to the jnx_vector_contains 
.br
\fIdatain\fP iis the value to check the vector for 
.br
\fIvector_comparison\fP is the functor callback for comparison, 1 is a positive find, 0 is a negative 
.RE
.PP
\fBReturns:\fP
.RS 4
either 1 on success or 0 on failure 
.RE
.PP

.SS "\fBjnx_int32\fP jnx_vector_contains_ts (\fBjnx_vector\fP * vector, void * datain, int32_t(*)(void *a, void *b) vector_comparison)"

.SS "jnx_vector_count (\fBjnx_vector\fP * vector)"

.PP
\fBParameters:\fP
.RS 4
\fIvector\fP is the pojnx_int32er to the vector to count 
.RE
.PP
\fBReturns:\fP
.RS 4
number of vector elements 
.RE
.PP

.SS "\fBjnx_size\fP jnx_vector_count_ts (\fBjnx_vector\fP * vector)"

.SS "jnx_vector_create (void)"

.PP
Function that createialises internal vector structures\&. Call this function before you call any other function from the API\&. 
.SS "void jnx_vector_destroy (\fBjnx_vector\fP ** vector)"

.SS "jnx_vector_insert (\fBjnx_vector\fP * vector, void * value)"

.PP
inserts jnx_int32o the next position in the vector 
.PP
\fBParameters:\fP
.RS 4
\fIvector\fP pojnx_int32s to the vector to insert int32_to 
.br
\fIvalue\fP value for insertion cast jnx_int32o void* 
.RE
.PP

.SS "jnx_vector_insert_at (\fBjnx_vector\fP * vector, \fBjnx_int32\fP position, void * value)"

.PP
inserts jnx_int32o the vector at a particular position, if it doesn't exist it will be crearted 
.PP
\fBParameters:\fP
.RS 4
\fIvector\fP 
.br
\fIposition\fP 
.br
\fIvalue\fP 
.RE
.PP

.SS "void jnx_vector_insert_at_ts (\fBjnx_vector\fP * vector, \fBjnx_int32\fP position, void * value)"

.SS "void jnx_vector_insert_ts (\fBjnx_vector\fP * vector, void * value)"

.SS "jnx_vector_last (\fBjnx_vector\fP * vector)"

.PP
returns the last data entry in the vector and shortens it by 1 
.PP
\fBParameters:\fP
.RS 4
\fIvector\fP pojnx_int32s to the vector to use
.RE
.PP
\fBReturns:\fP
.RS 4
returns void* data from the last vector entry 
.RE
.PP

.SS "void* jnx_vector_last_ts (\fBjnx_vector\fP * vector)"

.SS "jnx_vector_remove_at (\fBjnx_vector\fP * vector, \fBjnx_int32\fP position)"

.PP
removes an entry at position in the vector 
.PP
\fBParameters:\fP
.RS 4
\fIvector\fP pojnx_int32s to the target vector 
.br
\fIposition\fP target position 
.RE
.PP
\fBReturns:\fP
.RS 4
returns the value, returns NULL on error 
.RE
.PP

.SS "void* jnx_vector_remove_at_ts (\fBjnx_vector\fP * vector, \fBjnx_int32\fP position)"

.SH "Author"
.PP 
Generated automatically by Doxygen for jnxlibc from the source code\&.
