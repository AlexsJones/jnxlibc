.TH "jnxstack.h" 3 "Sat Jun 7 2014" "jnxlibc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jnxstack.h \- 
.PP
API for jnxlibc implementation of stack data structure\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'jnxthread\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBjnx_snode\fP"
.br
.RI "\fINode represents an element of the stack\&. \fP"
.ti -1c
.RI "struct \fBjnx_stack\fP"
.br
.RI "\fIRepresents the stack data structure as seen by the user\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBjnx_snode\fP \fBjnx_snode\fP"
.br
.RI "\fINode represents an element of the stack\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBjnx_stack\fP * \fBjnx_stack_create\fP (void)"
.br
.RI "\fIReturns the newly created stack\&. \fP"
.ti -1c
.RI "int \fBjnx_stack_is_empty\fP (\fBjnx_stack\fP *A)"
.br
.RI "\fIReturns 1 (true) if the stack is empty, and 0 otherwise\&. \fP"
.ti -1c
.RI "int \fBjnx_stack_is_empty_ts\fP (\fBjnx_stack\fP *A)"
.br
.ti -1c
.RI "void \fBjnx_stack_push\fP (\fBjnx_stack\fP *A, void *_datain)"
.br
.RI "\fIAccepts a void pointer to input data to push onto the stack\&. \fP"
.ti -1c
.RI "void \fBjnx_stack_push_ts\fP (\fBjnx_stack\fP *A, void *_datain)"
.br
.ti -1c
.RI "void * \fBjnx_stack_pop\fP (\fBjnx_stack\fP *A)"
.br
.RI "\fIPops the top element off the stack and returns it\&. \fP"
.ti -1c
.RI "void * \fBjnx_stack_pop_ts\fP (\fBjnx_stack\fP *A)"
.br
.ti -1c
.RI "void \fBjnx_stack_destroy\fP (\fBjnx_stack\fP **A)"
.br
.in -1c
.SH "Detailed Description"
.PP 
API for jnxlibc implementation of stack data structure\&. 

#include <jnxc_headers/jnxstack\&.h> 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBjnx_snode\fP  \fBjnx_snode\fP"

.PP
Node represents an element of the stack\&. 
.SH "Function Documentation"
.PP 
.SS "jnx_stack_create (void)"

.PP
Returns the newly created stack\&. 
.PP
\fBReturns:\fP
.RS 4
jnx_stack* to a newly created stack of 0 length\&. 
.RE
.PP

.SS "void jnx_stack_destroy (\fBjnx_stack\fP **A)"

.SS "jnx_stack_is_empty (\fBjnx_stack\fP *A)"

.PP
Returns 1 (true) if the stack is empty, and 0 otherwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP is the target stack\&. 
.RE
.PP

.SS "int jnx_stack_is_empty_ts (\fBjnx_stack\fP *A)"

.SS "jnx_stack_pop (\fBjnx_stack\fP *A)"

.PP
Pops the top element off the stack and returns it\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP is a pointer to the target stack\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The data element that was just popped off the stack or NULL if the stack is empty\&. 
.RE
.PP

.SS "void* jnx_stack_pop_ts (\fBjnx_stack\fP *A)"

.SS "jnx_stack_push (\fBjnx_stack\fP *A, void *_datain)"

.PP
Accepts a void pointer to input data to push onto the stack\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP is the target stack 
.br
\fI_datain\fP is the data to insert 
.RE
.PP

.SS "void jnx_stack_push_ts (\fBjnx_stack\fP *A, void *_datain)"

.SH "Author"
.PP 
Generated automatically by Doxygen for jnxlibc from the source code\&.
