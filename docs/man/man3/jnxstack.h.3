.TH "jnxstack.h" 3 "Sun Feb 1 2015" "jnxlibc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jnxstack.h \- API for jnxlibc implementation of stack data structure\&.  

.SH SYNOPSIS
.br
.PP
\fC#include 'jnxthread\&.h'\fP
.br
\fC#include 'jnxtypes\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBjnx_snode\fP"
.br
.RI "\fINode represents an element of the stack\&. \fP"
.ti -1c
.RI "struct \fBjnx_stack\fP"
.br
.RI "\fIRepresents the stack data structure as seen by the user\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBjnx_snode\fP \fBjnx_snode\fP"
.br
.RI "\fINode represents an element of the stack\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBjnx_stack\fP * \fBjnx_stack_create\fP (void)"
.br
.RI "\fIReturns the newly created stack\&. \fP"
.ti -1c
.RI "\fBjnx_int32\fP \fBjnx_stack_is_empty\fP (\fBjnx_stack\fP *A)"
.br
.RI "\fIReturns 1 (true) if the stack is empty, and 0 otherwise\&. \fP"
.ti -1c
.RI "\fBjnx_int32\fP \fBjnx_stack_is_empty_ts\fP (\fBjnx_stack\fP *A)"
.br
.ti -1c
.RI "void \fBjnx_stack_push\fP (\fBjnx_stack\fP *A, void *_datain)"
.br
.RI "\fIAccepts a void pojnx_int32er to input data to push onto the stack\&. \fP"
.ti -1c
.RI "void \fBjnx_stack_push_ts\fP (\fBjnx_stack\fP *A, void *_datain)"
.br
.ti -1c
.RI "void * \fBjnx_stack_pop\fP (\fBjnx_stack\fP *A)"
.br
.RI "\fIPops the top element off the stack and returns it\&. \fP"
.ti -1c
.RI "void * \fBjnx_stack_pop_ts\fP (\fBjnx_stack\fP *A)"
.br
.ti -1c
.RI "\fBjnx_int32\fP \fBjnx_stack_contains\fP (\fBjnx_stack\fP *A, void *datain, int32_t(*stack_comparison)(void *a, void *b))"
.br
.RI "\fIchecks the given stack for whether a value exists within it \fP"
.ti -1c
.RI "\fBjnx_int32\fP \fBjnx_stack_contains_ts\fP (\fBjnx_stack\fP *A, void *datain, int32_t(*stack_comparison)(void *a, void *b))"
.br
.ti -1c
.RI "void \fBjnx_stack_destroy\fP (\fBjnx_stack\fP **A)"
.br
.in -1c
.SH "Detailed Description"
.PP 
API for jnxlibc implementation of stack data structure\&. 

#include <jnxc_headers/jnxstack\&.h> 
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBjnx_snode\fP  \fBjnx_snode\fP"

.PP
Node represents an element of the stack\&. 
.SH "Function Documentation"
.PP 
.SS "jnx_stack_contains (\fBjnx_stack\fP * A, void * datain, int32_t(*)(void *a, void *b) stack_comparison)"

.PP
checks the given stack for whether a value exists within it 
.PP
\fBParameters:\fP
.RS 4
\fIdatain\fP is the value to check for 
.br
\fIstack_comparison\fP is the functor given by the user for evaluation, 1 on success, 0 on failure 
.RE
.PP
\fBReturns:\fP
.RS 4
either 1 on contains or 0 on no entry found 
.RE
.PP

.SS "\fBjnx_int32\fP jnx_stack_contains_ts (\fBjnx_stack\fP * A, void * datain, int32_t(*)(void *a, void *b) stack_comparison)"

.SS "jnx_stack_create (void)"

.PP
Returns the newly created stack\&. 
.PP
\fBReturns:\fP
.RS 4
jnx_stack* to a newly created stack of 0 length\&. 
.RE
.PP

.SS "void jnx_stack_destroy (\fBjnx_stack\fP ** A)"

.SS "jnx_stack_is_empty (\fBjnx_stack\fP * A)"

.PP
Returns 1 (true) if the stack is empty, and 0 otherwise\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP is the target stack\&. 
.RE
.PP

.SS "\fBjnx_int32\fP jnx_stack_is_empty_ts (\fBjnx_stack\fP * A)"

.SS "jnx_stack_pop (\fBjnx_stack\fP * A)"

.PP
Pops the top element off the stack and returns it\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP is a pojnx_int32er to the target stack\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
The data element that was just popped off the stack or NULL if the stack is empty\&. 
.RE
.PP

.SS "void* jnx_stack_pop_ts (\fBjnx_stack\fP * A)"

.SS "jnx_stack_push (\fBjnx_stack\fP * A, void * _datain)"

.PP
Accepts a void pojnx_int32er to input data to push onto the stack\&. 
.PP
\fBParameters:\fP
.RS 4
\fIA\fP is the target stack 
.br
\fI_datain\fP is the data to insert 
.RE
.PP

.SS "void jnx_stack_push_ts (\fBjnx_stack\fP * A, void * _datain)"

.SH "Author"
.PP 
Generated automatically by Doxygen for jnxlibc from the source code\&.
