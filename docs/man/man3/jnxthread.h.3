.TH "jnxthread.h" 3 "Sun Apr 27 2014" "jnxlibc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jnxthread.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <pthread\&.h>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBjnx_thread_attributes\fP"
.br
.ti -1c
.RI "struct \fBjnx_thread\fP"
.br
.ti -1c
.RI "union \fBjnx_thread_mutex\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct 
.br
\fBjnx_thread_attributes\fP \fBjnx_thread_attributes\fP"
.br
.ti -1c
.RI "typedef void *( \fBentry_point\fP )(void *)"
.br
.ti -1c
.RI "typedef struct \fBjnx_thread\fP \fBjnx_thread\fP"
.br
.ti -1c
.RI "typedef union \fBjnx_thread_mutex\fP \fBjnx_thread_mutex\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBjnx_thread_unlock\fP (\fBjnx_thread_mutex\fP *m)"
.br
.ti -1c
.RI "void \fBjnx_thread_lock\fP (\fBjnx_thread_mutex\fP *m)"
.br
.RI "\fIblocking function that will wait for the mutex to unlock \fP"
.ti -1c
.RI "int \fBjnx_thread_trylock\fP (\fBjnx_thread_mutex\fP *m)"
.br
.ti -1c
.RI "void \fBjnx_thread_poolflush\fP ()"
.br
.RI "\fIresets the pool and removes thread data \fP"
.ti -1c
.RI "size_t \fBjnx_thread_poolcount\fP ()"
.br
.RI "\fIcounts the current number of threads in the pool \fP"
.ti -1c
.RI "\fBjnx_thread\fP * \fBjnx_thread_create\fP (\fBentry_point\fP e, void *args)"
.br
.RI "\fIjnx_thread_create will create and start a new thread, adding to the pool \fP"
.ti -1c
.RI "int \fBjnx_thread_create_disposable\fP (\fBentry_point\fP e, void *args)"
.br
.RI "\fIjnx_thread_create will create and start a new thread but does not add to pool \fP"
.ti -1c
.RI "void \fBjnx_thread_destroy\fP (\fBjnx_thread\fP *thr)"
.br
.RI "\fIDestroy the thread data structure and pool listing\&. \fP"
.ti -1c
.RI "int \fBjnx_thread_join\fP (\fBjnx_thread\fP *thr, void **data)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef void*( entry_point)(void *)"

.SS "typedef struct \fBjnx_thread\fP \fBjnx_thread\fP"

.SS "typedef struct \fBjnx_thread_attributes\fP \fBjnx_thread_attributes\fP"

.SS "typedef union \fBjnx_thread_mutex\fP \fBjnx_thread_mutex\fP"

.SH "Function Documentation"
.PP 
.SS "\fBjnx_thread\fP * jnx_thread_create (\fBentry_point\fPe, void *args)"

.PP
jnx_thread_create will create and start a new thread, adding to the pool 
.PP
\fBParameters:\fP
.RS 4
\fIentry_point\fP is the function pointer the thread starts with 
.br
\fIargs\fP are the arguments to pass the function pointer 
.RE
.PP
\fBReturns:\fP
.RS 4
\fBjnx_thread\fP object 
.RE
.PP

.SS "int jnx_thread_create_disposable (\fBentry_point\fPe, void *args)"

.PP
jnx_thread_create will create and start a new thread but does not add to pool 
.PP
\fBParameters:\fP
.RS 4
\fIentry_point\fP is the function pointer the thread starts with 
.br
\fIargs\fP are the arguments to pass the function pointer 
.RE
.PP
\fBReturns:\fP
.RS 4
error code if any 
.RE
.PP

.SS "void jnx_thread_destroy (\fBjnx_thread\fP *thr)"

.PP
Destroy the thread data structure and pool listing\&. 
.PP
\fBWarning:\fP
.RS 4
Destroy will not ensure thread is killed 
.RE
.PP

.SS "int jnx_thread_join (\fBjnx_thread\fP *thr, void **data)"

.SS "jnx_thread_lock (\fBjnx_thread_mutex\fP *m)"

.PP
blocking function that will wait for the mutex to unlock 
.PP
\fBParameters:\fP
.RS 4
\fI\fBjnx_thread_mutex\fP\fP to lock 
.RE
.PP

.SS "size_t jnx_thread_poolcount ()"

.PP
counts the current number of threads in the pool 
.PP
\fBWarning:\fP
.RS 4
does not give thread status active/inactive 
.RE
.PP
\fBReturns:\fP
.RS 4
size_t of thread count 
.RE
.PP

.SS "void jnx_thread_poolflush ()"

.PP
resets the pool and removes thread data 
.PP
\fBWarning:\fP
.RS 4
Does not ensure threads have terminated 
.RE
.PP

.SS "int jnx_thread_trylock (\fBjnx_thread_mutex\fP *m)"

.SS "int jnx_thread_unlock (\fBjnx_thread_mutex\fP *m)"

.SH "Author"
.PP 
Generated automatically by Doxygen for jnxlibc from the source code\&.
