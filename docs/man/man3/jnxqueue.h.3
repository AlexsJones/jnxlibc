.TH "jnxqueue.h" 3 "Sun Feb 1 2015" "jnxlibc" \" -*- nroff -*-
.ad l
.nh
.SH NAME
jnxqueue.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'jnxtypes\&.h'\fP
.br
\fC#include 'jnxlist\&.h'\fP
.br
\fC#include 'jnxthread\&.h'\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "struct \fBjnx_queue\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fBjnx_queue\fP \fBjnx_queue\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBjnx_queue_push\fP (\fBjnx_queue\fP *q, void *data)"
.br
.RI "\fIpushes an item onto the queue \fP"
.ti -1c
.RI "void \fBjnx_queue_push_ts\fP (\fBjnx_queue\fP *q, void *data)"
.br
.ti -1c
.RI "void * \fBjnx_queue_pop\fP (\fBjnx_queue\fP *q)"
.br
.RI "\fIpops the first available item off of the queue \fP"
.ti -1c
.RI "void * \fBjnx_queue_pop_ts\fP (\fBjnx_queue\fP *q)"
.br
.ti -1c
.RI "size_t \fBjnx_queue_count\fP (\fBjnx_queue\fP *q)"
.br
.RI "\fIget the queue size \fP"
.ti -1c
.RI "size_t \fBjnx_queue_count_ts\fP (\fBjnx_queue\fP *q)"
.br
.ti -1c
.RI "\fBjnx_queue\fP * \fBjnx_queue_create\fP ()"
.br
.RI "\fIcreate a \fBjnx_queue\fP \fP"
.ti -1c
.RI "void \fBjnx_queue_destroy\fP (\fBjnx_queue\fP **q)"
.br
.RI "\fIdestroys a \fBjnx_queue\fP \fP"
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fBjnx_queue\fP \fBjnx_queue\fP"

.SH "Function Documentation"
.PP 
.SS "size_t jnx_queue_count (\fBjnx_queue\fP * q)"

.PP
get the queue size 
.PP
\fBParameters:\fP
.RS 4
\fIq\fP is a pointer to the queue to use 
.RE
.PP
\fBReturns:\fP
.RS 4
the size of queue, 0 on empty or error 
.RE
.PP

.SS "size_t jnx_queue_count_ts (\fBjnx_queue\fP * q)"

.SS "\fBjnx_queue\fP * jnx_queue_create ()"

.PP
create a \fBjnx_queue\fP 
.PP
\fBReturns:\fP
.RS 4
a pointer to \fBjnx_queue\fP 
.RE
.PP

.SS "void jnx_queue_destroy (\fBjnx_queue\fP ** q)"

.PP
destroys a \fBjnx_queue\fP 
.PP
\fBParameters:\fP
.RS 4
\fIq\fP is a pointer to the queue to use 
.RE
.PP

.SS "void * jnx_queue_pop (\fBjnx_queue\fP * q)"

.PP
pops the first available item off of the queue 
.PP
\fBParameters:\fP
.RS 4
\fIq\fP is a pointer to the queue to use 
.RE
.PP
\fBReturns:\fP
.RS 4
the first queue item or NULL on error 
.RE
.PP

.SS "void* jnx_queue_pop_ts (\fBjnx_queue\fP * q)"

.SS "void jnx_queue_push (\fBjnx_queue\fP * q, void * data)"

.PP
pushes an item onto the queue 
.PP
\fBParameters:\fP
.RS 4
\fIq\fP is a pointer to the queue to use 
.br
\fIdata\fP is the data to store 
.RE
.PP

.SS "void jnx_queue_push_ts (\fBjnx_queue\fP * q, void * data)"

.SH "Author"
.PP 
Generated automatically by Doxygen for jnxlibc from the source code\&.
